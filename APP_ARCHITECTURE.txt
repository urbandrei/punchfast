================================================================================
                        PUNCHFAST APPLICATION ARCHITECTURE
                    Comprehensive Technical Documentation v1.0
================================================================================

Table of Contents:
  1. Overview & Tech Stack
  2. Application Architecture
  3. Folder Structure
  4. API Documentation
  5. Dependencies
  6. Feature Deep Dives
     6.1 Automatic Routes
     6.2 Store Data Enrichment & Reporting
     6.3 Achievements System
     6.4 Automatic Cuisine Detection
     6.5 Account Persistence
     6.6 Business Accounts & Dashboards
  7. Data Flow Diagrams
  8. Database Schema Reference

================================================================================
1. OVERVIEW & TECH STACK
================================================================================

PunchFast is a rewards platform for smaller businesses, enabling customers to
discover nearby food establishments, complete visits, earn achievements, and
participate in curated food routes. Businesses can register to manage punch
cards and view analytics.

TECH STACK:
-----------
Frontend:
  - React 19.1.1 (UI framework)
  - React Router DOM 7.9.1 (client-side routing)
  - OpenLayers 10.7.0 (interactive mapping)
  - Axios 1.12.0 (HTTP client)

Backend:
  - Node.js with Express 5.1.0 (web server)
  - Sequelize 6.37.7 (ORM)
  - PostgreSQL via pg 8.16.3 (database)
  - JWT via jsonwebtoken 9.0.2 (authentication)
  - bcryptjs 3.0.2 (password hashing)

External Services:
  - OpenStreetMap Overpass API (store discovery)
  - Nominatim API (geocoding/reverse geocoding)
  - Python AI Model (cuisine classification)


================================================================================
2. APPLICATION ARCHITECTURE
================================================================================

MONOREPO STRUCTURE:
-------------------
The application uses a monorepo with separate client/server workspaces.

Entry Points:
  - Server: /server/index.js (line 66-118)
  - Client: /client/src/App.js

Server Startup Sequence (server/index.js):
  1. Load environment variables (dotenv)
  2. Initialize Express app
  3. Register middleware (JSON parsing)
  4. Mount API routes under /api prefix
  5. Authenticate database connection (Sequelize)
  6. Sync database schema (alter: true)
  7. Create default admin account if not exists
  8. Start background enrichment service
  9. Listen on PORT (default: 5000)

CLIENT-SERVER COMMUNICATION DIAGRAM:
------------------------------------

    +------------------+          HTTPS/REST           +------------------+
    |                  |  --------------------------->  |                  |
    |   React Client   |      Authorization: Bearer    |  Express Server  |
    |   (Port 3000)    |  <---------------------------  |   (Port 5000)    |
    |                  |         JSON Responses        |                  |
    +------------------+                               +------------------+
           |                                                    |
           |                                                    |
           v                                                    v
    +------------------+                               +------------------+
    |   localStorage   |                               |   PostgreSQL     |
    | (tokens, cache)  |                               |   (Sequelize)    |
    +------------------+                               +------------------+
                                                               |
                                                               v
                                                      +------------------+
                                                      | External APIs:   |
                                                      | - Overpass API   |
                                                      | - Nominatim API  |
                                                      | - AI Classifier  |
                                                      +------------------+


================================================================================
3. FOLDER STRUCTURE
================================================================================

/workspaces/punchfast/
|
+-- package.json              # Root monorepo config
|
+-- /client/                  # React Frontend
|   +-- package.json          # Client dependencies
|   +-- /public/              # Static assets
|   +-- /build/               # Production bundle
|   +-- /src/
|       +-- App.js            # Main router and state
|       +-- index.js          # React DOM entry
|       +-- index.css         # Global styles
|       +-- /components/      # Reusable UI components
|       |   +-- UnifiedAuthModal.jsx
|       |   +-- MapView.jsx
|       |   +-- MapControls.jsx
|       |   +-- AchievementModal.jsx
|       |   +-- QuestionnaireModal.jsx
|       |   +-- Navbar.jsx
|       |   +-- routeCard.jsx
|       |   +-- storeCard.jsx
|       +-- /views/           # Page components
|       |   +-- home.jsx
|       |   +-- dashboard.jsx
|       |   +-- achievements.jsx
|       |   +-- business_dashboard.jsx
|       |   +-- admin_dashboard.jsx
|       +-- /utils/           # Client utilities
|           +-- apiClient.js      # JWT-enabled fetch wrapper
|           +-- tokenManager.js   # Token storage
|           +-- proximityUtils.js # Geolocation helpers
|
+-- /server/                  # Express Backend
|   +-- index.js              # Server entry point
|   +-- package.json          # Server dependencies
|   +-- /config/
|   |   +-- database.js       # Sequelize connection
|   +-- /models/              # Database models
|   |   +-- user.js
|   |   +-- business.js
|   |   +-- store.js
|   |   +-- visit.js
|   |   +-- routes.js
|   |   +-- routeStart.js
|   |   +-- routeStore.js
|   |   +-- achievement.js
|   |   +-- userachievement.js
|   |   +-- savedStore.js
|   |   +-- report.js
|   |   +-- associations.js   # Model relationships
|   +-- /controllers/         # Request handlers
|   |   +-- authController.js
|   |   +-- storeController.js
|   |   +-- visitController.js
|   |   +-- routeController.js
|   |   +-- achievementController.js
|   |   +-- adminController.js
|   |   +-- reportController.js
|   +-- /routes/              # API route definitions
|   |   +-- authRoutes.js
|   |   +-- achievementRoutes.js
|   |   +-- adminRoutes.js
|   |   +-- reportRoutes.js
|   +-- /middleware/
|   |   +-- authMiddleware.js # JWT verification
|   +-- /services/
|   |   +-- storeEnrichmentService.js
|   |   +-- nominatimService.js
|   +-- /logic/
|   |   +-- searchForStores.js
|   |   +-- aiCuisineClassifier.js
|   |   +-- overpassRateLimiter.js
|   |   +-- /clustering/
|   |       +-- clusterGenerator.js
|   |       +-- mstAlgorithm.js
|   |       +-- cuisineExtractor.js
|   |       +-- geographicNaming.js
|   +-- /utils/
|   |   +-- jwtUtils.js
|   |   +-- distanceUtils.js
|   +-- /scripts/
|       +-- resetDatabase.js
|       +-- seedAchievements.js
|
+-- /ai/                      # AI Models
|   +-- /auto-cuisine/
|       +-- bow_cuisine.py    # Bag-of-Words cuisine classifier
|       +-- /models/          # Trained model files
|
+-- /data-pipeline/           # Python ETL scripts
    +-- /scripts/
        +-- clean_osm.py
        +-- classify_stores.py
        +-- insert_to_postgres.py


================================================================================
4. API DOCUMENTATION
================================================================================

All API endpoints are mounted under the /api prefix.
Base URL: http://localhost:5000/api (development)

------------------------------------------------------------------------------
4.1 INTERNAL API ENDPOINTS
------------------------------------------------------------------------------

HEALTH CHECK
------------
GET /api
  Returns: { status: 'healthy', timestamp: ISO string }
  File: server/routes/authRoutes.js:14

CUSTOMER AUTHENTICATION
-----------------------
POST /api/login
  Body: { username, password }
  Returns: { user, accessToken, refreshToken }
  File: server/controllers/authController.js:23

POST /api/signup
  Body: { username, password }
  Returns: { user, accessToken, refreshToken }
  File: server/controllers/authController.js:79

POST /api/refresh-token
  Body: { refreshToken }
  Returns: { accessToken, refreshToken }
  Note: Implements token rotation (old token invalidated)
  File: server/controllers/authController.js:135

POST /api/logout (auth required)
  Clears refresh token from database
  File: server/controllers/authController.js:213

GET /api/session (auth required)
  Returns: { session: { userId, username, isAdmin, deviceInfo, ... } }
  File: server/controllers/authController.js:243

POST /api/change-password (auth required)
  Body: { currentPassword, newPassword }
  Note: Invalidates all refresh tokens (forces re-login)
  File: server/controllers/authController.js:277

BUSINESS AUTHENTICATION
-----------------------
POST /api/business/signup
  Body: { username, password }
  Returns: { business } with status: 'pending'
  Note: NO tokens returned - must wait for admin approval
  File: server/controllers/authController.js:312

POST /api/business/login
  Body: { username, password }
  Returns: { business, accessToken, refreshToken }
  Note: Fails if status != 'approved'
  File: server/controllers/authController.js:347

POST /api/business/refresh-token
  Body: { refreshToken }
  Returns: { accessToken, refreshToken }
  File: server/controllers/authController.js:409

POST /api/business/logout (business auth required)
  File: server/controllers/authController.js:487

GET /api/business/session (business auth required)
  File: server/controllers/authController.js:517

BUSINESS MANAGEMENT
-------------------
POST /api/approve-business
  Header: x-admin-token: ADMIN_TOKEN
  Body: { username }
  File: server/controllers/authController.js:552

GET /api/business-offer?username=...
  Returns: { goal }
  File: server/controllers/authController.js:579

PUT /api/business-offer
  Body: { username, goal }
  File: server/controllers/authController.js:597

STORES
------
GET /api/stores/nearby?lat=&lng=&limit=&offset=
  Returns nearby stores with pagination
  File: server/controllers/storeController.js

POST /api/stores (optional auth)
  Body: { name, latitude, longitude, ... }
  Note: Triggers AI cuisine classification if website provided
  File: server/controllers/storeController.js

GET /api/stores/:storeId/verification
  Returns store verification status (is business-verified)
  File: server/controllers/storeController.js

VISITS
------
POST /api/visits
  Body: { userId, storeId }
  Returns: { visit, shouldShowQuestionnaire }
  Note: May trigger achievement unlocking
  File: server/controllers/visitController.js

GET /api/visits/:userId
  Returns all visits for a user
  File: server/controllers/visitController.js

GET /api/visits/store-stats
  Returns visit statistics for stores
  File: server/controllers/visitController.js

GET /api/visits/route-progress
  Returns route completion progress for user
  File: server/controllers/visitController.js

ROUTES
------
POST /api/routes
  Body: { name, routeType, storeIds }
  Creates manual route
  File: server/controllers/routeController.js

GET /api/routes/nearby?lat=&lng=
  Returns nearby routes sorted by distance
  File: server/controllers/routeController.js

ROUTE PARTICIPATION
-------------------
POST /api/route-starts
  Body: { userId, routeId }
  Starts user participation in route
  File: server/controllers/routeStartController.js

PUT /api/route-starts/leave
  Body: { userId, routeId }
  Exits route participation
  File: server/controllers/routeStartController.js

GET /api/users/:userId/route-starts
  Returns user's active routes
  File: server/controllers/routeStartController.js

SAVED STORES
------------
POST /api/saved-stores/toggle
  Body: { userId, storeId }
  Toggles store in user favorites
  File: server/controllers/savedStoresController.js

GET /api/saved-stores/:userId
  Returns user's saved stores
  File: server/controllers/savedStoresController.js

GET /api/saved-stores/:userId/:storeId
  Checks if specific store is saved
  File: server/controllers/savedStoresController.js

ACHIEVEMENTS
------------
GET /api/achievements
  Returns all achievements
  File: server/controllers/achievementController.js:4

GET /api/achievements/user/:userId
  Returns user's earned achievements
  File: server/controllers/achievementController.js:13

GET /api/achievements/all-with-progress/:userId
  Returns ALL achievements with user's progress status
  File: server/controllers/achievementController.js:45

GET /api/achievements/newly-unlocked/:userId
  Returns achievements with firstShown=false (for notifications)
  File: server/controllers/achievementController.js:80

POST /api/achievements/award
  Body: { userId, achievementId }
  Manually awards achievement
  File: server/controllers/achievementController.js:25

POST /api/achievements/mark-shown
  Body: { userId, achievementId }
  Marks achievement notification as displayed
  File: server/controllers/achievementController.js:108

REPORTS
-------
POST /api/reports (optional auth)
  Body: { reportedItemType, reportedItemId, category, description }
  Categories: closed_permanently, wrong_location, duplicate,
              inappropriate_content, spam, other
  File: server/controllers/reportController.js

GET /api/reports (admin only)
  Query: ?status=pending|reviewed|resolved|dismissed
  File: server/controllers/reportController.js

PUT /api/reports/:reportId (admin only)
  Body: { status, adminNotes }
  File: server/controllers/reportController.js

QUESTIONNAIRES
--------------
GET /api/questionnaire/pending
  Returns pending questionnaire for user
  File: server/controllers/questionnaireController.js

GET /api/questionnaire/question
  Returns next questionnaire question
  File: server/controllers/questionnaireController.js

POST /api/questionnaire/answer
  Body: { userId, storeId, question, answer }
  File: server/controllers/questionnaireController.js

ADMIN
-----
GET /api/admin/stats (admin auth)
  Returns dashboard statistics
  File: server/controllers/adminController.js

GET /api/admin/pending-businesses (admin auth)
  Returns businesses awaiting approval
  File: server/controllers/adminController.js

POST /api/admin/approve-business (admin auth)
  Body: { businessId, storeId (optional) }
  File: server/controllers/adminController.js

POST /api/admin/deny-business (admin auth)
  Body: { businessId }
  File: server/controllers/adminController.js

NEARBY ELIGIBLE STORES
----------------------
GET /api/nearby-eligible-stores?lat=&lng=
  Returns stores eligible for visit based on proximity
  File: server/controllers/nearbyEligibleStoresController.js

PUNCHES
-------
POST /api/punch
  Body: { userId, storeId }
  Records punch for verified business punchcard
  File: server/controllers/punchesController.js

------------------------------------------------------------------------------
4.2 EXTERNAL API INTEGRATIONS
------------------------------------------------------------------------------

OPENSTREETMAP OVERPASS API
--------------------------
Purpose: Discover food/beverage establishments by geographic location
Endpoint: https://overpass-api.de/api/interpreter
Method: POST
Rate Limit: 1 request per 1.5 seconds
File: server/logic/searchForStores.js

Query types:
  - amenity: cafe, fast_food, restaurant, bar, pub
  - shop: bakery, convenience, deli, coffee, ice_cream

Rate limiter implementation: server/logic/overpassRateLimiter.js

NOMINATIM API (OpenStreetMap)
-----------------------------
Purpose: Geocoding and reverse geocoding for address data
Base URL: https://nominatim.openstreetmap.org
Endpoints:
  - /search (address -> coordinates)
  - /reverse (coordinates -> address)
Rate Limit: 1 request per 1.5 seconds
User-Agent: PunchFast/1.0 (contact@punchfast.com)
Timeout: 10 seconds
File: server/services/nominatimService.js

PYTHON AI CUISINE CLASSIFIER
----------------------------
Purpose: Classify restaurant cuisine from website content
Type: Local subprocess (not HTTP)
Script: ai/auto-cuisine/bow_cuisine.py
Model: Bag-of-Words classifier
Confidence Threshold: 80%
Timeout: 15 seconds (default), 30 seconds (max)
File: server/logic/aiCuisineClassifier.js

------------------------------------------------------------------------------
4.3 IMPORTANT API NOTES
------------------------------------------------------------------------------

RATE LIMITING:
  - Overpass API: 1.5s minimum between requests (enforced)
  - Nominatim API: 1.5s minimum between requests (enforced)
  - Both use queued request systems to prevent rate limit violations

TOKEN REFRESH:
  - Access tokens expire in 1 hour
  - Refresh tokens expire in 30 days
  - Token rotation: Each refresh invalidates the previous refresh token
  - Client auto-refreshes on 401 response (client/src/utils/apiClient.js)

ERROR RESPONSES:
  - 400: Bad request / validation error
  - 401: Authentication required
  - 403: Forbidden / token expired or invalid
  - 404: Resource not found
  - 500: Server error

AUTHENTICATION MIDDLEWARE:
  - authenticateUser: Verifies user JWT (type: 'user')
  - authenticateBusiness: Verifies business JWT (type: 'business')
  - optionalAuth: Extracts user if token present, continues otherwise
  File: server/middleware/authMiddleware.js


================================================================================
5. DEPENDENCIES
================================================================================

------------------------------------------------------------------------------
5.1 CLIENT DEPENDENCIES (/client/package.json)
------------------------------------------------------------------------------

CORE FRAMEWORK:
  react: ^19.1.1
    Purpose: UI component framework
    Usage: All components use React functional components with hooks

  react-dom: ^19.1.1
    Purpose: React DOM rendering
    Usage: Entry point (client/src/index.js)

  react-scripts: 5.0.1
    Purpose: Create React App build toolchain
    Usage: Development server, production builds, testing

ROUTING:
  react-router-dom: ^7.9.1
    Purpose: Client-side routing
    Usage: App.js defines routes, navigation between views

HTTP CLIENT:
  axios: ^1.12.0
    Purpose: HTTP request library with interceptors
    Usage: client/src/utils/apiClient.js wraps Axios with JWT handling
    Features: Auto token refresh, request/response interceptors

MAPPING:
  ol: ^10.7.0 (OpenLayers)
    Purpose: Interactive geospatial mapping
    Usage: client/src/components/MapView.jsx
    Features: Vector layers, markers, user location tracking

TESTING:
  @testing-library/react: ^16.3.0
    Purpose: React component testing utilities

  @testing-library/jest-dom: ^6.8.0
    Purpose: Custom Jest matchers for DOM

  @testing-library/user-event: ^14.6.1
    Purpose: User interaction simulation

  @testing-library/dom: ^10.4.1
    Purpose: DOM testing utilities

PERFORMANCE:
  web-vitals: ^5.1.0
    Purpose: Core Web Vitals measurement

CONFIGURATION:
  proxy: "http://localhost:5000"
    Purpose: Proxies API requests to backend during development

------------------------------------------------------------------------------
5.2 SERVER DEPENDENCIES (/server/package.json)
------------------------------------------------------------------------------

WEB FRAMEWORK:
  express: ^5.1.0
    Purpose: HTTP server and routing
    Usage: Main server setup, route handling, middleware
    Note: Using Express 5 (async error handling built-in)

DATABASE:
  sequelize: ^6.37.7
    Purpose: ORM for PostgreSQL
    Usage: All database models and queries
    Features: Migrations, associations, hooks

  pg: ^8.16.3
    Purpose: PostgreSQL driver
    Usage: Database connection pool

  pg-hstore: ^2.3.4
    Purpose: Serialize/deserialize JSON to PostgreSQL hstore
    Usage: JSON fields in models (deviceInfo, etc.)

AUTHENTICATION:
  jsonwebtoken: ^9.0.2
    Purpose: JWT generation and verification
    Usage: server/utils/jwtUtils.js
    Tokens: Access (1hr), Refresh (30 days)

  bcryptjs: ^3.0.2
    Purpose: Password hashing
    Usage: User/Business model hooks (beforeCreate)
    Salt rounds: 10

CONFIGURATION:
  dotenv: ^17.2.2
    Purpose: Environment variable loading
    Usage: Loads .env file on server startup
    Variables: DATABASE_URL, PORT, ADMIN_TOKEN, etc.

DATA EXPORT:
  json2csv: ^6.0.0-alpha.2
    Purpose: Convert JSON to CSV
    Usage: server/scripts/exportStoresToCSV.js

------------------------------------------------------------------------------
5.3 ROOT PACKAGE CONFIGURATION
------------------------------------------------------------------------------

/package.json defines the monorepo:

{
  "workspaces": ["client", "server"],
  "scripts": {
    "start": "cd server && NODE_ENV=production node index.js",
    "dev": "concurrently \"yarn dev:client\" \"yarn dev:server\"",
    "build": "cd client && yarn build"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}


================================================================================
6. FEATURE DEEP DIVES
================================================================================

------------------------------------------------------------------------------
6.1 AUTOMATIC ROUTES
------------------------------------------------------------------------------

Overview:
  Routes are automatically generated by clustering nearby stores of the same
  cuisine type using a Minimum Spanning Tree (MST) algorithm.

Key Files:
  - server/logic/clustering/clusterGenerator.js (main orchestration)
  - server/logic/clustering/mstAlgorithm.js (MST implementation)
  - server/logic/clustering/cuisineExtractor.js (cuisine grouping)
  - server/logic/clustering/geographicNaming.js (route naming)
  - server/models/routes.js (Route model)
  - server/models/routeStore.js (Route-Store junction)

ALGORITHM FLOW:

1. FETCH STORES IN AREA (clusterGenerator.js:11-42)
   - Query stores within bounding box
   - Filter by status: 'active'
   - Required attributes: id, name, lat, lng, cuisine, amenity, shop

2. FILTER UNCLUSTERED STORES (clusterGenerator.js:44-76)
   - Find all routes with isAutoGenerated=true
   - Get store IDs already in those routes
   - Exclude those stores from clustering

3. GROUP BY CUISINE (cuisineExtractor.js)
   - Extract cuisine from: cuisine field > amenity > shop
   - Normalize to lowercase with underscores
   - Group stores into Map<cuisine, Store[]>

4. BUILD MST PER CUISINE GROUP (mstAlgorithm.js)
   - Skip groups with < 3 or > 200 stores
   - Calculate distances using Haversine formula
   - Build MST using Kruskal's algorithm with Union-Find
   - Max edge distance: 5 km

5. SPLIT MST INTO CLUSTERS (mstAlgorithm.js)
   - Target cluster size: 3-7 stores
   - Split by removing longest edges
   - Validate all edges < 5 km

6. CREATE ROUTES (clusterGenerator.js:78-110)
   - Generate name: "[City] [Cuisine] Trail" (geographicNaming.js)
   - Order stores using MST edges
   - Create Route with isAutoGenerated=true
   - Create RouteStore entries with order

DATABASE SCHEMA:

Route model (server/models/routes.js:4-37):
  - id: INTEGER (PK, auto-increment)
  - name: STRING (required)
  - routeType: STRING (cuisine type)
  - isAutoGenerated: BOOLEAN (default: false)
  - created_at, updated_at: DATE

RouteStore model (junction table):
  - routeId: INTEGER (FK to Route)
  - storeId: INTEGER (FK to Store)
  - order: INTEGER (position in route)

CODE EXAMPLE - Route Creation:

  // clusterGenerator.js:78-110
  async function createRouteFromCluster(cluster, cuisine, geoCache, mstEdges) {
    return await sequelize.transaction(async (t) => {
      const routeName = await generateClusterName(cluster, cuisine, geoCache);

      const route = await Route.create({
        name: routeName,
        routeType: normalizeCuisineType(cuisine),
        isAutoGenerated: true  // <-- Key flag
      }, { transaction: t });

      const orderedStoreIds = orderStoresFromMST(cluster, mstEdges, haversineDistance);

      const routeStoreData = orderedStoreIds.map((storeId, index) => ({
        routeId: route.id,
        storeId: storeId,
        order: index + 1
      }));

      await RouteStore.bulkCreate(routeStoreData, { transaction: t });

      return { routeId: route.id, name: routeName, storeCount: cluster.length };
    });
  }

------------------------------------------------------------------------------
6.2 STORE DATA ENRICHMENT AND REPORTING
------------------------------------------------------------------------------

Overview:
  A singleton background service runs continuously, enriching store data by
  adding missing addresses (reverse geocoding) or coordinates (geocoding).

Key Files:
  - server/services/storeEnrichmentService.js (main service)
  - server/services/nominatimService.js (geocoding API)
  - server/controllers/reportController.js (user reports)
  - server/models/store.js (enrichment fields)

ENRICHMENT SERVICE ARCHITECTURE:

Service Class: StoreEnrichmentService (singleton)
File: server/services/storeEnrichmentService.js:16-343

Lifecycle:
  - start(): Begins 1.5s interval loop
  - stop(): Clears interval (called on SIGINT/SIGTERM)
  - processNextStore(): Finds and enriches one store

PRIORITY ORDER (findStoreNeedingEnrichment, line 88-150):

  Priority 1: Has coordinates, missing address
    Query: enrichment_status='unchanged', lat/lng NOT NULL,
           address='unknown' OR addr_city/street/housenumber all NULL
    Action: reverseGeocodeStore()

  Priority 2: Has address, missing coordinates
    Query: enrichment_status='unchanged', lat/lng IS NULL,
           address != 'unknown', has addr_street or addr_city
    Action: geocodeStore()

  Priority 3: Has incomplete address
    Query: enrichment_status='unchanged', has lat/lng,
           ANY of 6 fields NULL (housenumber, street, city, state, zip, country)
    Action: completeAddress()

ENRICHMENT STATUS VALUES (server/models/store.js:306-310):
  - 'unchanged': Not yet processed
  - 'geocoded': Coordinates added from address
  - 'reverse_geocoded': Address added from coordinates
  - 'address_completed': Missing address fields filled
  - 'failed': Enrichment attempted but unsuccessful

CODE EXAMPLE - Reverse Geocoding:

  // storeEnrichmentService.js:216-248
  async reverseGeocodeStore(store) {
    const result = await reverseGeocode(store.latitude, store.longitude);

    if (!result) {
      await this.markAsFailed(store);
      return;
    }

    await store.update({
      address: result.address,
      addr_housenumber: result.addr_housenumber,
      addr_street: result.addr_street,
      addr_city: result.addr_city,
      addr_state: result.addr_state,
      addr_postcode: result.addr_postcode,
      addr_country: result.addr_country,
      enrichment_status: 'reverse_geocoded',
      enrichment_attempted_at: new Date()
    });
  }

REPORTING SYSTEM:

Report Categories (reportController.js):
  - closed_permanently: Store is permanently closed
  - wrong_location: Incorrect location information
  - duplicate: Duplicate store entry
  - inappropriate_content: Inappropriate listing
  - spam: Spam or fraudulent listing
  - other: Other issues

Report Status Flow:
  pending -> reviewed -> resolved
                     -> dismissed

Report Model Fields:
  - reportedItemType: 'store' | 'route'
  - reportedItemId: INTEGER
  - reporterId: INTEGER (nullable for anonymous)
  - category: STRING
  - description: TEXT
  - status: ENUM
  - reviewedBy: INTEGER (admin who reviewed)
  - reviewedAt: DATE
  - adminNotes: TEXT

------------------------------------------------------------------------------
6.3 ACHIEVEMENTS SYSTEM
------------------------------------------------------------------------------

Overview:
  Users earn achievements by completing activities (visits, routes, surveys).
  Achievements are polled and displayed as modal notifications.

Key Files:
  - server/models/achievement.js (Achievement model)
  - server/models/userachievement.js (UserAchievement junction)
  - server/controllers/achievementController.js (API handlers)
  - server/scripts/seedAchievements.js (seed data)
  - client/src/views/achievements.jsx (UI)

DATABASE SCHEMA:

Achievement Model (server/models/achievement.js:4-41):
  - id: INTEGER (PK)
  - name: STRING (unique)
  - description: STRING
  - type: STRING (category: 'visits', 'routes', 'questionnaire')
  - condition: INTEGER (threshold number)

UserAchievement Model:
  - id: INTEGER (PK)
  - userId: INTEGER (FK)
  - achievementId: INTEGER (FK)
  - unlockedAt: DATE (when earned)
  - firstShown: BOOLEAN (has user seen notification)

ACHIEVEMENT TYPES:
  - Visit-based: "First Visit", "Regular", "Explorer" (1, 10, 50 visits)
  - Route-based: "Traveler", "Route Master" (start routes, complete routes)
  - Survey-based: "Contributor" (answer questionnaires)

TRIGGER POINTS:
  Achievements are checked and awarded in these controllers:
  - visitController.js: After recording a visit
  - routeStartController.js: After starting/completing a route
  - questionnaireController.js: After answering a question

NOTIFICATION FLOW:

1. Achievement Unlocked (in controller):
   UserAchievement.create({ userId, achievementId, firstShown: false })

2. Client Polls for New Achievements:
   GET /api/achievements/newly-unlocked/:userId
   Returns achievements where firstShown=false

3. Display Modal:
   AchievementModal component shows unlock notification

4. Mark as Shown:
   POST /api/achievements/mark-shown
   Updates firstShown=true

CODE EXAMPLE - Check Achievement Progress:

  // achievementController.js:45-78
  exports.getAllAchievementsWithProgress = async (req, res) => {
    const { userId } = req.params;

    const allAchievements = await Achievement.findAll();
    const userAchievements = await UserAchievement.findAll({
      where: { userId },
      include: [{ model: Achievement, as: 'achievementData' }]
    });

    const userAchievementMap = {};
    userAchievements.forEach(ua => {
      userAchievementMap[ua.achievementId] = {
        unlocked: true,
        unlockedAt: ua.unlockedAt
      };
    });

    const achievementsWithProgress = allAchievements.map(ach => ({
      id: ach.id,
      name: ach.name,
      description: ach.description,
      type: ach.type,
      condition: ach.condition,
      unlocked: !!userAchievementMap[ach.id],
      unlockedAt: userAchievementMap[ach.id]?.unlockedAt || null
    }));

    res.json({ achievements: achievementsWithProgress });
  };

------------------------------------------------------------------------------
6.4 AUTOMATIC CUISINE DETECTION
------------------------------------------------------------------------------

Overview:
  When a store is created with a website URL but no cuisine, an AI model
  analyzes the website content to classify the cuisine type.

Key Files:
  - server/logic/aiCuisineClassifier.js (Node.js wrapper)
  - ai/auto-cuisine/bow_cuisine.py (Python model)
  - ai/auto-cuisine/models/ (trained model files)
  - server/models/store.js (cuisine tracking fields)

CLASSIFICATION SOURCES (priority order):
  1. OSM data: Store already has cuisine field from OpenStreetMap
  2. Manual entry: User provides cuisine on store creation
  3. AI classification: Website analyzed for cuisine type
  4. Fallback: Uses amenity/shop field (cafe, restaurant, etc.)

AI CLASSIFIER CONFIGURATION (aiCuisineClassifier.js:7-14):

  const CONFIG = {
    pythonPath: 'python3',
    scriptPath: path.join(__dirname, '../../ai/auto-cuisine/bow_cuisine.py'),
    modelDir: path.join(__dirname, '../../ai/auto-cuisine/models'),
    defaultTimeout: 15000,  // 15 seconds
    maxTimeout: 30000,      // 30 seconds
    confidenceThreshold: 0.8  // 80% minimum
  };

CLASSIFICATION PROCESS (classifyCuisineFromUrl, line 55-193):

1. Validate URL format (http/https)
2. Spawn Python subprocess with arguments:
   python3 bow_cuisine.py predict --url <url> --timeout <sec> --model_dir <path>
3. Capture stdout (JSON) and stderr (errors)
4. Parse response and check confidence threshold
5. Return classification result

RESPONSE FORMATS:

Success:
  {
    success: true,
    cuisine: 'italian',
    confidence: 0.8765,
    source: 'ai_autofilled'
  }

Failure:
  {
    success: false,
    error: 'low_confidence' | 'no_html' | 'timeout' | 'python_error',
    source: 'ai_failed',
    details: 'Error message'
  }

STORE SCHEMA FIELDS (server/models/store.js:127-146):

  cuisine_source: ENUM
    Values: 'manual', 'osm', 'ai_autofilled', 'ai_failed', 'no_website'

  cuisine_confidence: FLOAT
    Range: 0.0 - 1.0 (for AI classifications)

  cuisine_ai_error: STRING
    Error type if AI classification failed

  cuisine_classified_at: DATE
    Timestamp of classification attempt

CODE EXAMPLE - Attempt Classification:

  // aiCuisineClassifier.js:202-247
  async function attemptCuisineClassification(storeData) {
    const { website, cuisine, osm_id } = storeData;

    // Case 1: Cuisine already exists
    if (cuisine) {
      return {
        cuisine_source: osm_id ? 'osm' : 'manual',
        cuisine_confidence: null,
        cuisine_ai_error: null,
        cuisine_classified_at: null
      };
    }

    // Case 2: No website available
    if (!website) {
      return {
        cuisine_source: 'no_website',
        cuisine_confidence: null,
        cuisine_ai_error: null,
        cuisine_classified_at: null
      };
    }

    // Case 3: Attempt AI classification
    const result = await classifyCuisineFromUrl(website);
    const timestamp = new Date();

    if (result.success) {
      return {
        cuisine: result.cuisine,
        cuisine_source: 'ai_autofilled',
        cuisine_confidence: result.confidence,
        cuisine_ai_error: null,
        cuisine_classified_at: timestamp
      };
    } else {
      return {
        cuisine_source: 'ai_failed',
        cuisine_confidence: null,
        cuisine_ai_error: result.error,
        cuisine_classified_at: timestamp
      };
    }
  }

------------------------------------------------------------------------------
6.5 ACCOUNT PERSISTENCE
------------------------------------------------------------------------------

Overview:
  JWT-based authentication with access/refresh token rotation. Tokens are
  stored client-side in localStorage and server-side (hashed) in database.

Key Files:
  - server/controllers/authController.js (auth endpoints)
  - server/utils/jwtUtils.js (token utilities)
  - server/models/user.js (User model with token fields)
  - server/middleware/authMiddleware.js (JWT verification)
  - client/src/utils/tokenManager.js (client token storage)
  - client/src/utils/apiClient.js (auto token refresh)

TOKEN ARCHITECTURE:

Access Token (1 hour):
  - Contains: { id, username, type: 'user', isAdmin }
  - Signed with: JWT_ACCESS_SECRET
  - Sent in: Authorization: Bearer <token>
  - Never stored in database

Refresh Token (30 days):
  - Contains: { id, username, type: 'user' }
  - Signed with: JWT_REFRESH_SECRET
  - Stored HASHED in database
  - Used only to get new access tokens

USER MODEL TOKEN FIELDS (server/models/user.js:43-67):

  refreshToken: TEXT
    Hashed refresh token (bcrypt)

  refreshTokenCreatedAt: DATE
    When current refresh token was issued

  refreshTokenExpiresAt: DATE
    When refresh token expires (30 days from creation)

  deviceInfo: JSON
    { userAgent, ip, platform, browser }

  lastLoginIp: STRING
    IP address of most recent login

AUTHENTICATION FLOW:

1. LOGIN (authController.js:23-74):
   - Verify credentials (bcrypt.compare)
   - Generate access token (1 hour)
   - Generate refresh token (30 days)
   - Hash refresh token (bcrypt, 10 rounds)
   - Store hashed token + metadata in database
   - Return both tokens to client

2. TOKEN REFRESH (authController.js:135-208):
   - Verify JWT signature of refresh token
   - Verify token type is 'user'
   - Find user by ID in token
   - Compare hashed tokens (bcrypt.compare)
   - Check database expiry date
   - Generate NEW tokens (rotation)
   - Store new hashed refresh token
   - Return new tokens

3. LOGOUT (authController.js:213-238):
   - Clear refresh token from database
   - Clear token timestamps

PASSWORD SECURITY:
  - Hashed on creation with bcrypt beforeCreate hook
  - Salt rounds: 10
  - Change password invalidates all refresh tokens

CLIENT-SIDE STORAGE (tokenManager.js):
  - localStorage.accessToken
  - localStorage.refreshToken
  - localStorage.userId
  - localStorage.username

AUTO-REFRESH (apiClient.js):
  - Intercepts 401 responses
  - Calls /api/refresh-token with stored refresh token
  - Retries original request with new access token
  - If refresh fails, clears storage and redirects to login

CODE EXAMPLE - Token Rotation:

  // authController.js:172-197
  // TOKEN ROTATION: Generate new tokens
  const newAccessToken = generateAccessToken({
    id: user.id,
    username: user.username,
    type: 'user',
    isAdmin: user.isAdmin || false
  });

  const newRefreshToken = generateRefreshToken({
    id: user.id,
    username: user.username,
    type: 'user'
  });

  // Store new hashed refresh token (invalidates old one)
  const hashedRefreshToken = await hashRefreshToken(newRefreshToken);
  await user.update({
    refreshToken: hashedRefreshToken,
    refreshTokenCreatedAt: new Date(),
    refreshTokenExpiresAt: getRefreshTokenExpiry()
  });

------------------------------------------------------------------------------
6.6 BUSINESS ACCOUNTS AND DASHBOARDS
------------------------------------------------------------------------------

Overview:
  Business accounts are separate from user accounts, require admin approval,
  can be associated with a store, and have access to analytics dashboards.

Key Files:
  - server/models/business.js (Business model)
  - server/controllers/authController.js (business auth, line 312-620)
  - server/controllers/adminController.js (approval workflow)
  - client/src/views/business_dashboard.jsx (analytics UI)

BUSINESS vs USER COMPARISON:

| Feature           | User                | Business              |
|-------------------|---------------------|-----------------------|
| Token Type        | type: 'user'        | type: 'business'      |
| Account Creation  | Immediate access    | Pending approval      |
| Can Login         | Immediately         | Only after approval   |
| Associated Store  | None                | One store (optional)  |
| Punchcard Control | Sees goal           | Sets punch goal       |
| Admin Required    | No                  | Yes (for approval)    |
| Tracking Fields   | visits, routes, etc | None                  |

BUSINESS MODEL (server/models/business.js:5-89):

  username: STRING (unique, lowercased)
  password: STRING (bcrypt hashed)
  status: ENUM('pending', 'approved')
  goal: INTEGER (default: 10 punches per card)
  storeId: INTEGER (FK to Store, nullable)
  refreshToken, refreshTokenCreatedAt, refreshTokenExpiresAt
  deviceInfo, lastLoginIp

APPROVAL WORKFLOW:

1. Business signs up -> status='pending', no tokens
2. Appears in /api/admin/pending-businesses
3. Admin reviews and calls /api/admin/approve-business
   - Can optionally associate with storeId
   - Sets status='approved'
4. Business can now login and receives tokens

BUSINESS SIGNUP (authController.js:312-342):

  exports.businessSignup = async (req, res) => {
    const newBusiness = await Business.create({
      username,
      password,
      status: 'pending',  // <-- Key difference
      goal: 10
    });

    // NO TOKENS RETURNED - must wait for approval
    return res.status(201).json({
      message: 'Application submitted. Pending approval.',
      business: { id, username, status }
    });
  };

BUSINESS LOGIN (authController.js:347-404):

  exports.businessLogin = async (req, res) => {
    // ... verify credentials ...

    if (business.status !== 'approved') {
      return res.status(403).json({
        message: 'Your application is pending approval.'
      });
    }

    // Generate tokens with type: 'business' and storeId
    const accessToken = generateAccessToken({
      id: business.id,
      username: business.username,
      type: 'business',
      storeId: business.storeId  // <-- Included in token
    });

    // ... return tokens ...
  };

BUSINESS DASHBOARD (client/src/views/business_dashboard.jsx):

Features:
  - Punchcard Settings: Set punch goal and reward description
  - Statistics: Daily, monthly, lifetime punch counts
  - Top Customers: List of most active customers

Storage (localStorage):
  pf_business_settings_{businessId}: { goal, reward }
  pf_business_stats_{businessId}: { dailyTotal, monthlyTotal, lifetimeTotal, monthlyCustomers }

Note: Dashboard statistics are stored locally in the browser,
not synced to the server. This is by design for privacy.

STORE ASSOCIATION:

One-to-One relationship:
  - One business can own one store
  - One store can be owned by one business
  - Enforced during admin approval

When associated:
  - Business token includes storeId
  - Can view punch statistics for their store
  - Store shows "Verified Business" badge


================================================================================
7. DATA FLOW DIAGRAMS
================================================================================

------------------------------------------------------------------------------
7.1 CLIENT-SERVER COMMUNICATION
------------------------------------------------------------------------------

    +-------------+                                    +----------------+
    |   Browser   |                                    | Express Server |
    | (React App) |                                    |   Port 5000    |
    +-------------+                                    +----------------+
          |                                                   |
          |  1. GET /api/stores/nearby?lat=X&lng=Y            |
          |-------------------------------------------------->|
          |                                                   |
          |                        +------------------------+ |
          |                        | Check if stores exist  | |
          |                        | in DB for this area    | |
          |                        +------------------------+ |
          |                                   |               |
          |                   [If not cached] |               |
          |                                   v               |
          |                        +------------------------+ |
          |                        | Query Overpass API     | |
          |                        | (rate limited 1.5s)    | |
          |                        +------------------------+ |
          |                                   |               |
          |                                   v               |
          |                        +------------------------+ |
          |                        | Save to PostgreSQL     | |
          |                        | via Sequelize          | |
          |                        +------------------------+ |
          |                                                   |
          |  2. JSON Response: [{ id, name, lat, lng, ... }]  |
          |<--------------------------------------------------|
          |                                                   |
          |  3. POST /api/visits { userId, storeId }          |
          |-------------------------------------------------->|
          |                                                   |
          |                        +------------------------+ |
          |                        | Create Visit record    | |
          |                        | Check achievements     | |
          |                        | Maybe trigger survey   | |
          |                        +------------------------+ |
          |                                                   |
          |  4. { visit, shouldShowQuestionnaire }            |
          |<--------------------------------------------------|
          |                                                   |

------------------------------------------------------------------------------
7.2 AUTHENTICATION FLOW
------------------------------------------------------------------------------

    +--------+                    +---------+                  +----------+
    | Client |                    | Server  |                  | Database |
    +--------+                    +---------+                  +----------+
        |                             |                             |
        | 1. POST /api/login          |                             |
        |    {username, password}     |                             |
        |---------------------------->|                             |
        |                             |                             |
        |                             | 2. Find user by username    |
        |                             |---------------------------->|
        |                             |                             |
        |                             | 3. User record              |
        |                             |<----------------------------|
        |                             |                             |
        |                             | 4. bcrypt.compare(password) |
        |                             |                             |
        |                             | 5. Generate tokens:         |
        |                             |    - Access (1hr)           |
        |                             |    - Refresh (30 days)      |
        |                             |                             |
        |                             | 6. Hash refresh token       |
        |                             |                             |
        |                             | 7. Save hashed token        |
        |                             |---------------------------->|
        |                             |                             |
        | 8. {user, accessToken,      |                             |
        |     refreshToken}           |                             |
        |<----------------------------|                             |
        |                             |                             |
        | 9. Store in localStorage    |                             |
        |                             |                             |
        |                             |                             |
   [Later - Access Token Expired]     |                             |
        |                             |                             |
        | 10. POST /api/refresh-token |                             |
        |     {refreshToken}          |                             |
        |---------------------------->|                             |
        |                             |                             |
        |                             | 11. Verify JWT signature    |
        |                             |                             |
        |                             | 12. Find user by ID         |
        |                             |---------------------------->|
        |                             |                             |
        |                             | 13. Compare hashed tokens   |
        |                             |                             |
        |                             | 14. Generate NEW tokens     |
        |                             |     (old ones invalidated)  |
        |                             |                             |
        |                             | 15. Save new hashed token   |
        |                             |---------------------------->|
        |                             |                             |
        | 16. {accessToken,           |                             |
        |      refreshToken}          |                             |
        |<----------------------------|                             |
        |                             |                             |

------------------------------------------------------------------------------
7.3 STORE ENRICHMENT PIPELINE
------------------------------------------------------------------------------

    +----------------------+
    | Server Startup       |
    | (index.js:106)       |
    +----------------------+
              |
              v
    +----------------------+
    | enrichmentService    |
    | .start()             |
    +----------------------+
              |
              v
    +----------------------+     No stores    +------------------+
    | Find store needing   |----------------->| Wait 1.5 seconds |
    | enrichment           |                  | (log once/min)   |
    +----------------------+                  +------------------+
              |                                        |
              | Found store                            |
              v                                        |
    +----------------------+                           |
    | Determine type:      |                           |
    | - Has coords, no addr|                           |
    | - Has addr, no coords|                           |
    | - Incomplete address |                           |
    +----------------------+                           |
              |                                        |
              v                                        |
    +----------------------+                           |
    | Call Nominatim API   |<--------------------------+
    | (rate limited 1.5s)  |
    +----------------------+
              |
              | Success
              v
    +----------------------+
    | Update store record: |
    | - addr_* fields      |
    | - enrichment_status  |
    | - enrichment_time    |
    +----------------------+
              |
              | Failure
              v
    +----------------------+
    | Mark as 'failed'     |
    | Record attempt time  |
    +----------------------+

------------------------------------------------------------------------------
7.4 ACHIEVEMENT UNLOCK SEQUENCE
------------------------------------------------------------------------------

    +--------+                    +---------+                  +----------+
    | Client |                    | Server  |                  | Database |
    +--------+                    +---------+                  +----------+
        |                             |                             |
        | 1. POST /api/visits         |                             |
        |    {userId, storeId}        |                             |
        |---------------------------->|                             |
        |                             |                             |
        |                             | 2. Create Visit             |
        |                             |---------------------------->|
        |                             |                             |
        |                             | 3. Increment user.visits    |
        |                             |---------------------------->|
        |                             |                             |
        |                             | 4. Check achievements:      |
        |                             |    visits >= condition?     |
        |                             |---------------------------->|
        |                             |                             |
        |                             | 5. If threshold met:        |
        |                             |    Create UserAchievement   |
        |                             |    {firstShown: false}      |
        |                             |---------------------------->|
        |                             |                             |
        | 6. {visit}                  |                             |
        |<----------------------------|                             |
        |                             |                             |
   [30 seconds later - polling]       |                             |
        |                             |                             |
        | 7. GET /api/achievements/   |                             |
        |    newly-unlocked/:userId   |                             |
        |---------------------------->|                             |
        |                             |                             |
        |                             | 8. Find where               |
        |                             |    firstShown=false         |
        |                             |---------------------------->|
        |                             |                             |
        | 9. {achievements: [...]}    |                             |
        |<----------------------------|                             |
        |                             |                             |
        | 10. Show modal              |                             |
        |                             |                             |
        | 11. POST /api/achievements/ |                             |
        |     mark-shown              |                             |
        |---------------------------->|                             |
        |                             |                             |
        |                             | 12. Update firstShown=true  |
        |                             |---------------------------->|
        |                             |                             |

------------------------------------------------------------------------------
7.5 AUTOMATIC ROUTE GENERATION
------------------------------------------------------------------------------

    +-------------------+
    | Input: BoundingBox|
    | {bottomLeft,      |
    |  topRight}        |
    +-------------------+
            |
            v
    +-------------------+
    | Query stores in   |
    | bounding box      |
    | (status='active') |
    +-------------------+
            |
            v
    +-------------------+
    | Filter out stores |
    | already in auto-  |
    | generated routes  |
    +-------------------+
            |
            v
    +-------------------+
    | Group by cuisine: |
    | Map<cuisine,      |
    |     Store[]>      |
    +-------------------+
            |
            v
    +-------------------+
    | For each cuisine  |
    | group (3-200):    |
    +-------------------+
            |
            v
    +-------------------+
    | Build MST using   |
    | Haversine distance|
    | Max edge: 5km     |
    +-------------------+
            |
            v
    +-------------------+
    | Split MST into    |
    | clusters (3-7     |
    | stores each)      |
    +-------------------+
            |
            v
    +-------------------+
    | Validate clusters |
    | (all edges < 5km) |
    +-------------------+
            |
            v
    +-------------------+
    | For each valid    |
    | cluster:          |
    +-------------------+
            |
            +---> Generate name: "[City] [Cuisine] Trail"
            |
            +---> Order stores using MST path
            |
            +---> Create Route {isAutoGenerated: true}
            |
            +---> Create RouteStore entries with order
            |
            v
    +-------------------+
    | Output:           |
    | {routesCreated,   |
    |  storesProcessed} |
    +-------------------+


================================================================================
8. DATABASE SCHEMA REFERENCE
================================================================================

------------------------------------------------------------------------------
8.1 USERS TABLE
------------------------------------------------------------------------------

CREATE TABLE "Users" (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    visits INTEGER DEFAULT 0,
    routes_started INTEGER DEFAULT 0,
    routes_completed INTEGER DEFAULT 0,
    questions_answered INTEGER DEFAULT 0,
    "isAdmin" BOOLEAN DEFAULT false,
    "refreshToken" TEXT,
    "refreshTokenCreatedAt" TIMESTAMP,
    "refreshTokenExpiresAt" TIMESTAMP,
    "deviceInfo" JSONB DEFAULT '{}',
    "lastLoginIp" VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

------------------------------------------------------------------------------
8.2 BUSINESSES TABLE
------------------------------------------------------------------------------

CREATE TABLE "Businesses" (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    status VARCHAR(255) DEFAULT 'pending',  -- 'pending' | 'approved'
    goal INTEGER DEFAULT 10,
    "storeId" INTEGER REFERENCES "Stores"(id),
    "refreshToken" TEXT,
    "refreshTokenCreatedAt" TIMESTAMP,
    "refreshTokenExpiresAt" TIMESTAMP,
    "deviceInfo" JSONB DEFAULT '{}',
    "lastLoginIp" VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

------------------------------------------------------------------------------
8.3 STORES TABLE (simplified - see server/models/store.js for full schema)
------------------------------------------------------------------------------

CREATE TABLE "Stores" (
    id SERIAL PRIMARY KEY,
    osm_id BIGINT,
    osm_type VARCHAR(255),  -- 'node' | 'way' | 'relation'
    name VARCHAR(255) NOT NULL,
    latitude FLOAT NOT NULL,
    longitude FLOAT NOT NULL,
    address VARCHAR(255) NOT NULL,
    addr_housenumber VARCHAR(255),
    addr_street VARCHAR(255),
    addr_city VARCHAR(255),
    addr_state VARCHAR(2),
    addr_postcode VARCHAR(255),
    addr_country VARCHAR(2),
    amenity VARCHAR(255),
    shop VARCHAR(255),
    cuisine VARCHAR(255),
    cuisine_source VARCHAR(255),  -- 'manual'|'osm'|'ai_autofilled'|'ai_failed'|'no_website'
    cuisine_confidence FLOAT,
    cuisine_ai_error VARCHAR(255),
    cuisine_classified_at TIMESTAMP,
    website VARCHAR(255),
    phone VARCHAR(255),
    opening_hours TEXT,
    status VARCHAR(255) DEFAULT 'active',  -- 'active'|'inactive'|'closed'|'pending'
    enrichment_status VARCHAR(255) DEFAULT 'unchanged',
    enrichment_attempted_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

------------------------------------------------------------------------------
8.4 ROUTES TABLE
------------------------------------------------------------------------------

CREATE TABLE "Routes" (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    "routeType" VARCHAR(255) NOT NULL,
    "isAutoGenerated" BOOLEAN DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

------------------------------------------------------------------------------
8.5 ROUTESTORES TABLE (junction)
------------------------------------------------------------------------------

CREATE TABLE "RouteStores" (
    "routeId" INTEGER REFERENCES "Routes"(id),
    "storeId" INTEGER REFERENCES "Stores"(id),
    "order" INTEGER,
    PRIMARY KEY ("routeId", "storeId")
);

------------------------------------------------------------------------------
8.6 VISITS TABLE
------------------------------------------------------------------------------

CREATE TABLE "Visits" (
    id SERIAL PRIMARY KEY,
    "userId" INTEGER REFERENCES "Users"(id),
    "storeId" INTEGER REFERENCES "Stores"(id),
    "visitDate" TIMESTAMP DEFAULT NOW(),
    "shouldShowQuestionnaire" BOOLEAN DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

------------------------------------------------------------------------------
8.7 ACHIEVEMENTS TABLE
------------------------------------------------------------------------------

CREATE TABLE "Achievements" (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description VARCHAR(255) NOT NULL,
    type VARCHAR(255) NOT NULL,
    condition INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

------------------------------------------------------------------------------
8.8 USERACHIEVEMENTS TABLE
------------------------------------------------------------------------------

CREATE TABLE "UserAchievements" (
    id SERIAL PRIMARY KEY,
    "userId" INTEGER REFERENCES "Users"(id),
    "achievementId" INTEGER REFERENCES "Achievements"(id),
    "unlockedAt" TIMESTAMP DEFAULT NOW(),
    "firstShown" BOOLEAN DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    UNIQUE ("userId", "achievementId")
);

------------------------------------------------------------------------------
8.9 REPORTS TABLE
------------------------------------------------------------------------------

CREATE TABLE "Reports" (
    id SERIAL PRIMARY KEY,
    "reportedItemType" VARCHAR(255) NOT NULL,  -- 'store' | 'route'
    "reportedItemId" INTEGER NOT NULL,
    "reporterId" INTEGER REFERENCES "Users"(id),
    category VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(255) DEFAULT 'pending',
    "reviewedBy" INTEGER REFERENCES "Users"(id),
    "reviewedAt" TIMESTAMP,
    "adminNotes" TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);


================================================================================
END OF DOCUMENT
================================================================================

Document Version: 1.0
Generated: December 2024
Source: PunchFast Application Codebase

For questions or updates, refer to the source code files listed throughout
this document.
