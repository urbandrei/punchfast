const { Store, Route, RouteStore } = require('../../models/associations');
const { Op } = require('sequelize');
const sequelize = require('../../config/database');
const { haversineDistance } = require('../../utils/distanceUtils');
const { groupStoresByCuisine, normalizeCuisineType } = require('./cuisineExtractor');
const { buildMST, splitMST, orderStoresFromMST, validateCluster } = require('./mstAlgorithm');
const { generateClusterName } = require('./geographicNaming');

const MAX_STORES_PER_CUISINE = 200;

async function fetchStoresInArea(boundingBox) {
    if (!boundingBox || !boundingBox.bottomLeft || !boundingBox.topRight) {
        console.warn('[Clustering] Invalid bounding box provided');
        return [];
    }

    const { bottomLeft, topRight } = boundingBox;

    try {
        const stores = await Store.findAll({
            where: {
                latitude: {
                    [Op.between]: [bottomLeft.lat, topRight.lat]
                },
                longitude: {
                    [Op.between]: [bottomLeft.lng, topRight.lng]
                },
                status: 'active'
            },
            attributes: [
                'id', 'name', 'latitude', 'longitude',
                'cuisine', 'amenity', 'shop',
                'addr_city', 'addr_state'
            ]
        });

        return stores;
    } catch (error) {
        console.error('[Clustering] Error fetching stores:', error);
        return [];
    }
}

async function getUnclusteredStores(stores) {
    if (!stores || stores.length === 0) {
        return [];
    }

    try {
        const autoRoutes = await Route.findAll({
            where: { isAutoGenerated: true },
            attributes: ['id']
        });

        if (autoRoutes.length === 0) {
            return stores;
        }

        const autoRouteIds = autoRoutes.map(r => r.id);

        const routeStores = await RouteStore.findAll({
            where: {
                routeId: { [Op.in]: autoRouteIds }
            },
            attributes: ['storeId'],
            raw: true
        });

        const clusteredIds = new Set(routeStores.map(rs => rs.storeId));

        return stores.filter(s => !clusteredIds.has(s.id));
    } catch (error) {
        console.error('[Clustering] Error filtering unclustered stores:', error);
        return stores;
    }
}

async function createRouteFromCluster(cluster, cuisine, geoCache, mstEdges) {
    try {
        return await sequelize.transaction(async (t) => {
            const routeName = await generateClusterName(cluster, cuisine, geoCache);

            const route = await Route.create({
                name: routeName,
                routeType: normalizeCuisineType(cuisine),
                isAutoGenerated: true
            }, { transaction: t });

            const orderedStoreIds = orderStoresFromMST(cluster, mstEdges, haversineDistance);

            const routeStoreData = orderedStoreIds.map((storeId, index) => ({
                routeId: route.id,
                storeId: storeId,
                order: index + 1
            }));

            await RouteStore.bulkCreate(routeStoreData, { transaction: t });

            return {
                routeId: route.id,
                name: routeName,
                storeCount: cluster.length,
                cuisine: cuisine
            };
        });
    } catch (error) {
        console.error(`[Clustering] Failed to create route for ${cuisine}:`, error);
        return null;
    }
}

async function generateRoutesFromNewStores(boundingBox, remainderBoxes) {
    console.log('[Clustering] Starting route generation');

    try {
        const storesInArea = await fetchStoresInArea(boundingBox);

        if (storesInArea.length === 0) {
            console.log('[Clustering] No stores found in search area');
            return {
                routesCreated: 0,
                storesProcessed: 0,
                routes: []
            };
        }

        console.log(`[Clustering] Found ${storesInArea.length} stores in area`);

        const unclusteredStores = await getUnclusteredStores(storesInArea);

        if (unclusteredStores.length === 0) {
            console.log('[Clustering] No unclustered stores available');
            return {
                routesCreated: 0,
                storesProcessed: 0,
                routes: []
            };
        }

        console.log(`[Clustering] Found ${unclusteredStores.length} unclustered stores`);

        const cuisineGroups = groupStoresByCuisine(unclusteredStores);

        console.log(`[Clustering] Processing ${cuisineGroups.size} cuisine groups`);

        const results = [];
        const geoCache = new Map();

        for (const [cuisine, stores] of cuisineGroups) {
            console.log(`[Clustering] ${cuisine}: ${stores.length} stores`);

            if (stores.length < 3) {
                console.log(`[Clustering] ${cuisine}: Skipped (too few stores)`);
                continue;
            }

            if (stores.length > MAX_STORES_PER_CUISINE) {
                console.log(`[Clustering] ${cuisine}: Skipped (too many stores, limit: ${MAX_STORES_PER_CUISINE})`);
                continue;
            }

            const mst = buildMST(stores, haversineDistance);

            if (mst.length === 0) {
                console.log(`[Clustering] ${cuisine}: Failed to build MST`);
                continue;
            }

            const clusters = splitMST(stores, mst, 3, 7);

            console.log(`[Clustering] ${cuisine}: Created ${clusters.length} potential clusters`);

            for (const cluster of clusters) {
                if (!validateCluster(cluster, mst)) {
                    console.log(`[Clustering] ${cuisine}: Cluster validation failed (edges too long)`);
                    continue;
                }

                const route = await createRouteFromCluster(cluster, cuisine, geoCache, mst);

                if (route) {
                    results.push(route);
                    console.log(`[Clustering] ${cuisine}: Created route "${route.name}" with ${route.storeCount} stores`);
                }
            }
        }

        console.log(`[Clustering] Complete: ${results.length} routes created`);

        return {
            routesCreated: results.length,
            storesProcessed: unclusteredStores.length,
            routes: results
        };

    } catch (error) {
        console.error('[Clustering] Error during route generation:', error);
        throw error;
    }
}

module.exports = {
    generateRoutesFromNewStores,
    fetchStoresInArea,
    getUnclusteredStores,
    createRouteFromCluster
};
